public static string[] ValidateBAMCFiles(string[] BAMCFiles)
{
    List<string> validFiles = [];
    foreach (string BAMCFile in BAMCFiles)
    {
        string fileName = Path.GetFileName(BAMCFile) ?? BAMCFile; // New to this syntax but Rosyln recommended using this syntax over a standard if (variable == null) { } check
        Console.WriteLine($"Validating BAMC File: {fileName}");
        try
        {
            bool isValid = true;
            int lineNumber = 1;
            using StreamReader reader = new(BAMCFile);
            {
                string? line = null; // ? Declares the variable as nullable
                while ((line = reader.ReadLine()) != null)
                {
                    string sanitizedLine = line.Trim().Replace("\n", "").Replace("\r", "");
                    if (!ValidLine(fileName, sanitizedLine, lineNumber))
                    {
                        isValid = false;
                        break;
                    }
                    lineNumber++;
                }
                if (isValid && lineNumber > 1)
                {
                    validFiles.Add(BAMCFile);
                }
            }
        }
        catch (IOException ie)
        {
            Console.WriteLine(ie.GetType().Name);
            Console.WriteLine(ie.Message);
        }
    }
    return [.. validFiles];
}
public static bool HandleLineValidation(string fileName, string line, int lineNumber)
{
    string[] lineArgs = line.Split(" ");
    string firstArg = lineArgs[0];
    switch (firstArg)
    {
        case "click" or "click-button" or "get-text" or "fill-textbox" or "select-dropdown" or "select-dropdown-element" or "save-as-html" or "take-screenshot" or "visit":
            string selectorString = "\"css-selector\""; // Defaults to "css-selector" for selector based actions
            if (firstArg.Equals("save-as-html"))  { selectorString = "filename.html"; }
            if (firstArg.Equals("take-screenshot")) { selectorString = "filename.png"; }

            if (lineArgs.Length != 2 || !lineArgs[1].StartsWith('"') || !lineArgs[1].EndsWith('"'))
            {
                Console.WriteLine($"[File \"{fileName}\"]:\nInvalid Line [Line {lineNumber}]:\n{line}\n\nValid Syntax:\n{firstArg} {selectorString}");
                return false;
            }
            return true;

        case "wait-for-seconds":
            if (lineArgs.Length != 2 || !int.TryParse(lineArgs[1], out int seconds) || seconds < 1)
            {
                Console.WriteLine($"[File \" {fileName} \"]:\nInvalid Line [Line {lineNumber}]:\n{line}\n\nValid Syntax:\n{firstArg} 5");
                return false;
            }
            return true;

        case "feature":
            if (lineArgs.Length != 2 || !featureArgs.Contains(lineArgs[1]) || !lineArgs[1].StartsWith('"') || !lineArgs[1].EndsWith('"'))
            {
                Console.WriteLine($"[File \" {fileName} \"]:\nInvalid Line [Line {lineNumber}]:\n{line}\n\nValid Syntax:\n{firstArg} \"feature-name\"");
                return false;
            }

           
            featureBlockFound = true; // Flag ensuring all 'feature' commands form a consecutive block at the file's start (ignoring empty/whitespace lines).
            return true;

        default:
            Console.WriteLine("Implement Me");
            return false;

    }
}
public static bool ValidLine(string fileName, string line, int lineNumber)
{
    if (line == null) return false;
    string trimmedLine = line.Trim();
    bool valid = false;
    foreach (string validArg in validArgs)
    {
        if (trimmedLine.StartsWith(validArg)) { valid = true; break; }
    }
    if (!valid || trimmedLine.Split(" ") == null) return false;
    return HandleLineValidation(fileName, line, lineNumber);

}